<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ELF x86 - Fake Instructions & Ptrace</title>
  
</head>
<body>
  <header>
    <link rel="stylesheet" href="../../style.css">
    <style>
      ul.liste-normale {
          all: revert !important;
      }

      ul.liste-normale li {
          all: revert !important;
      }
    </style>
  </header>
  <article>
    <h1>ELF x86 - Fake Instructions</h1>
    
    <h2>Initial Analysis</h2>
    <p>Let's analyze the file with the <code>file</code> command:</p>
    <pre><code>yoyo@LAPTOP:~/M1/S2/SL/rootme/craking/elf x86 - fake instruction$ file crackme
crackme: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, 
interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.8, with debug_info, not stripped</code></pre>
    
    <p>The <code>crackme</code> file is a 32-bit ELF executable for the x86 architecture (Intel 80386), compiled for Linux with dynamic linking to shared libraries via the interpreter <code>/lib/ld-linux.so.2</code>. It contains debug information and has not been "stripped", which means that symbols (function names, variables, etc.) are still present in the binary.</p>
    
    <p>The main obfuscation method relies on "fake instructions" such as indirect jumps (which we will detail later). In this assembly code, several functions are implemented such as <code>AES</code>, <code>RSA</code>, <code>blowfish</code>, <code>WPA</code> and <code>main</code>. The first four functions suggest encryption/decryption operations.</p>

    <h2>Main Function Analysis</h2>
    <p>Let's analyze the <code>main</code> function:</p>
    <pre><code>804858a:       8b 85 64 ff ff ff       mov    -0x9c(%ebp),%eax
8048590:       8b 00                   mov    (%eax),%eax
8048592:       89 44 24 04             mov    %eax,0x4(%esp)
8048596:       c7 04 24 f0 88 04 08    movl   $0x80488f0,(%esp)
804859d:       e8 9a fe ff ff          call   804843c &lt;printf@plt&gt;
80485a2:       c7 04 24 00 00 00 00    movl   $0x0,(%esp)
80485a9:       e8 de fe ff ff          call   804848c &lt;exit@plt&gt;</code></pre>
    
    <p>Here, the function tests if an argument is passed on the command line. Otherwise, it displays the correct syntax as illustrated here:</p>
    <pre><code>yoyo@LAPTOP:~/M1/S2/SL/rootme/craking/elf x86 - fake instruction$ ./crackme
(*) -Syntaxe: ./crackme [password]</code></pre>

    <h2>Indirect Function Call Discovery</h2>
    <p>By analyzing the code in more detail, we notice a particular instruction:</p>
    <pre><code>804868b:       c6 00 2e                movb   $0x2e,(%eax)
804868e:       8b 15 38 a0 04 08       mov    0x804a038,%edx
8048694:       8b 85 6c ff ff ff       mov    -0x94(%ebp),%eax</code></pre>
    
    <p>At instruction <code>0x804868e</code>, the address <code>0x804a038</code> is stored in <code>edx</code>. Looking at the code further, we notice that this address is none other than the address of <code>WPA</code>. Further on, we notice a call to <code>*%edx</code>, more specifically to <code>0x804a038</code>.</p>

    <h2>Register State Before WPA Call</h2>
    <pre><code>[----------------------------------registers-----------------------------------]
EAX: 0xffffd09e ("helloworld")
EBX: 0xf7fa3000 --&gt; 0x225dac
ECX: 0xffffd32d ("helloworld")
EDX: 0x80486c4 (&lt;WPA&gt;:  push   ebp)
ESI: 0xffffd194 --&gt; 0xffffd2e7 ("/home/yoyo/M1/S2/SL/rootme/craking/elf x86 - fake instruction/crackme")
EDI: 0xffffd09e ("helloworld")
EBP: 0xffffd0c8 --&gt; 0xf7ffd020 --&gt; 0xf7ffda40 --&gt; 0x0
ESP: 0xffffd010 --&gt; 0xffffd09e ("helloworld")
EIP: 0x80486a4 (&lt;main+336&gt;:     call   edx)
EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
    0x804869a &lt;main+326&gt;:        mov    DWORD PTR [esp+0x4],eax
    0x804869e &lt;main+330&gt;:        lea    eax,[ebp-0x2a]
    0x80486a1 &lt;main+333&gt;:        mov    DWORD PTR [esp],eax
=&gt; 0x80486a4 &lt;main+336&gt;:        call   edx
    0x80486a6 &lt;main+338&gt;:        mov    edx,DWORD PTR [ebp-0xc]
    0x80486a9 &lt;main+341&gt;:        xor    edx,DWORD PTR gs:0x14
    0x80486b0 &lt;main+348&gt;:        je     0x80486b7 &lt;main+355&gt;
    0x80486b2 &lt;main+350&gt;:        call   0x804845c &lt;__stack_chk_fail@plt&gt;
Guessed arguments:
arg[0]: 0xffffd09e ("helloworld")
arg[1]: 0x804b1a0 ("_0cGjc5m_.5T3Ç8CJ0À9")
[------------------------------------stack-------------------------------------]
0000| 0xffffd010 --&gt; 0xffffd09e ("helloworld")
0004| 0xffffd014 --&gt; 0x804b1a0 ("_0cGjc5m_.5T3Ç8CJ0À9")
0008| 0xffffd018 --&gt; 0xd ('\r')
0012| 0xffffd01c --&gt; 0x19
0016| 0xffffd020 --&gt; 0x0
0020| 0xffffd024 --&gt; 0xffffd03a ("_Celebration")
0024| 0xffffd028 --&gt; 0xffffd0a4 ("orld")
0028| 0xffffd02c --&gt; 0xffffd194</code></pre>
    
    <p>The <code>WPA</code> function therefore takes two parameters: the string "helloworld" that we sent on the command line, then <code>_0cGjc5m_.5T3Ç8CJ0À9</code>. Let's now analyze the <code>WPA</code> function.</p>

    <h2>WPA Function Analysis</h2>
    <pre><code>gdb-peda$ c
Continuing.
Vérification de votre mot de passe..
[----------------------------------registers-----------------------------------]
EAX: 0xffffd09e ("helloworld")
EBX: 0xf7fa3000 --&gt; 0x225dac
ECX: 0xf7fa49b4 --&gt; 0x0
EDX: 0x1
ESI: 0xffffd194 --&gt; 0xffffd2e7 ("/home/yoyo/M1/S2/SL/rootme/craking/elf x86 - fake instruction/crackme")
EDI: 0xffffd09e ("helloworld")
EBP: 0xffffd008 --&gt; 0xffffd0c8 --&gt; 0xf7ffd020 --&gt; 0xf7ffda40 --&gt; 0x0
ESP: 0xffffd000 --&gt; 0xffffd09e ("helloworld")
EIP: 0x80486f5 (&lt;WPA+49&gt;:       call   0x804847c &lt;strcmp@plt&gt;)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80486eb &lt;WPA+39&gt;:  mov    DWORD PTR [esp+0x4],eax
   0x80486ef &lt;WPA+43&gt;:  mov    eax,DWORD PTR [ebp+0x8]
   0x80486f2 &lt;WPA+46&gt;:  mov    DWORD PTR [esp],eax
=&gt; 0x80486f5 &lt;WPA+49&gt;:  call   0x804847c &lt;strcmp@plt&gt;
   0x80486fa &lt;WPA+54&gt;:  test   eax,eax
   0x80486fc &lt;WPA+56&gt;:  jne    0x804870f &lt;WPA+75&gt;
   0x80486fe &lt;WPA+58&gt;:  call   0x804872c &lt;blowfish&gt;
   0x8048703 &lt;WPA+63&gt;:  mov    DWORD PTR [esp],0x0
Guessed arguments:
arg[0]: 0xffffd09e ("helloworld")
arg[1]: 0x804b1a0 ("_0cGjc5m_.5\r\nÇ8CJ0À9")
[------------------------------------stack-------------------------------------]
0000| 0xffffd000 --&gt; 0xffffd09e ("helloworld")
0004| 0xffffd004 --&gt; 0x804b1a0 ("_0cGjc5m_.5\r\nÇ8CJ0À9")
0008| 0xffffd008 --&gt; 0xffffd0c8 --&gt; 0xf7ffd020 --&gt; 0xf7ffda40 --&gt; 0x0
0012| 0xffffd00c --&gt; 0x80486a6 (&lt;main+338&gt;:     mov    edx,DWORD PTR [ebp-0xc])
0016| 0xffffd010 --&gt; 0xffffd09e ("helloworld")
0020| 0xffffd014 --&gt; 0x804b1a0 ("_0cGjc5m_.5\r\nÇ8CJ0À9")
0024| 0xffffd018 --&gt; 0xd ('\r')
0028| 0xffffd01c --&gt; 0x19</code></pre>
    
    <p>In the <code>WPA</code> function, a call to <code>strcmp</code> is implemented on the arguments "helloworld" and <code>_0cGjc5m_.5\r\nÇ8CJ0À9</code>. The <code>strcmp</code> function is used to test if the strings are equal. If the test succeeds, the <code>blowfish</code> function launches and displays the correct flag. By advancing to <code>0x80486fa</code>, we can simply modify the <code>eax</code> register with <code>set $eax=0</code>.</p>

    <h2>Bypassing the Check</h2>
    <pre><code>gdb-peda$ set $eax=0
gdb-peda$ p $eax
$1 = 0x0</code></pre>
    
    <p>We continue execution and enter the <code>blowfish</code> function which generates the flag:</p>
    <pre><code>gdb-peda$ n
'+) Authentification réussie...
  U'r root!

  sh 3.0  password: &lt;censored&gt;
[Inferior 1 (process 3030) exited normally]</code></pre>

    <hr>
  </article>
</body>
</html>